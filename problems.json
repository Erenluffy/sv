[
  {
    "id": "and_gate_sv",
    "title": "AND Gate with Assertions",
    "description": "Implement a 2-input AND gate with SystemVerilog assertions to verify functionality.",
    "difficulty": "easy",
    "category": "Combinational Logic",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module(input logic a, b, output logic out);\n  // Implement AND gate\n  assign out = a & b;\n  \n  // Add assertions here\n  initial begin\n    $display(\"Starting AND gate simulation with assertions...\");\n  end\n  \n  // Immediate assertion\n  always_comb begin\n    assert (out === (a & b)) \n      else $error(\"AND gate failed: a=%0d, b=%0d, out=%0d\", a, b, out);\n  end\n  \n  // Cover points\n  cover property (@(*) (a && b));\n  cover property (@(*) (!a && !b));\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic a, b;\n  logic out;\n  integer passed = 0;\n  integer total = 0;\n  \n  top_module dut (.*);\n  \n  initial begin\n    $display(\"Testing AND gate with SystemVerilog...\");\n    \n    // Test all combinations\n    for (int i = 0; i < 4; i++) begin\n      {a, b} = i;\n      #10;\n      total++;\n      if (out === (a & b)) begin\n        passed++;\n        $display(\"PASS: a=%0d, b=%0d, out=%0d\", a, b, out);\n      end else begin\n        $display(\"FAIL: a=%0d, b=%0d, out=%0d (expected %0d)\", a, b, out, a & b);\n      end\n    end\n    \n    $display(\"\\nTest Results: %0d/%0d passed\", passed, total);\n    if (passed === total) $display(\"PASS\"); else $display(\"FAIL\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "dff_sv",
    "title": "D Flip-Flop with Properties",
    "description": "Implement a positive-edge triggered D flip-flop with SystemVerilog properties and assertions.",
    "difficulty": "medium",
    "category": "Sequential Logic",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module(input logic clk, rst_n, d, output logic q);\n  // Implement D flip-flop\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) q <= 0;\n    else q <= d;\n  end\n  \n  // Assertions\n  property p_reset;\n    @(negedge rst_n) !rst_n |=> q == 0;\n  endproperty\n  a_reset: assert property (p_reset);\n  \n  property p_data_flow;\n    @(posedge clk) disable iff (!rst_n)\n    d |=> q == d;\n  endproperty\n  a_data_flow: assert property (p_data_flow);\n  \n  // Coverage\n  cover property (@(posedge clk) d == 1);\n  cover property (@(posedge clk) d == 0);\n  cover property (@(negedge rst_n) 1);\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0, d = 0;\n  logic q;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"Testing D Flip-Flop with SystemVerilog assertions...\");\n    \n    // Reset sequence\n    #10 rst_n = 1;\n    \n    // Test data flow\n    d = 1; #10;\n    d = 0; #10;\n    d = 1; #10;\n    \n    // Test async reset\n    rst_n = 0; #5;\n    rst_n = 1; #5;\n    \n    $display(\"\\nSimulation complete. Check assertion results above.\");\n    #20 $finish;\n  end\n  \n  // Monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] clk posedge: d=%0d, q=%0d\", $time, d, q);\n  end\nendmodule"
  },
  {
    "id": "fifo_sv",
    "title": "FIFO with Assertions",
    "description": "Implement a synchronous FIFO with depth 4 and full SystemVerilog assertions for protocol checking.",
    "difficulty": "hard",
    "category": "Memory Elements",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module #(\n  parameter DEPTH = 4,\n  parameter WIDTH = 8\n)(\n  input logic clk, rst_n,\n  input logic wr_en, rd_en,\n  input logic [WIDTH-1:0] din,\n  output logic [WIDTH-1:0] dout,\n  output logic full, empty\n);\n  \n  logic [WIDTH-1:0] mem [0:DEPTH-1];\n  logic [$clog2(DEPTH):0] wr_ptr, rd_ptr;\n  \n  // Your FIFO implementation here\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      for (int i = 0; i < DEPTH; i++) mem[i] <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr[$clog2(DEPTH)-1:0]] <= din;\n        wr_ptr <= wr_ptr + 1;\n      end\n      \n      if (rd_en && !empty) begin\n        dout <= mem[rd_ptr[$clog2(DEPTH)-1:0]];\n        rd_ptr <= rd_ptr + 1;\n      end\n    end\n  end\n  \n  assign full = (wr_ptr - rd_ptr) == DEPTH;\n  assign empty = (wr_ptr == rd_ptr);\n  \n  // Assertions\n  property p_no_write_when_full;\n    @(posedge clk) disable iff (!rst_n)\n    full |-> !wr_en;\n  endproperty\n  a_no_write_when_full: assert property (p_no_write_when_full);\n  \n  property p_no_read_when_empty;\n    @(posedge clk) disable iff (!rst_n)\n    empty |-> !rd_en;\n  endproperty\n  a_no_read_when_empty: assert property (p_no_read_when_empty);\n  \n  property p_data_integrity;\n    @(posedge clk) disable iff (!rst_n)\n    (wr_en && !full) ##1 (rd_en && !empty) |-> dout == $past(din, 1);\n  endproperty\n  a_data_integrity: assert property (p_data_integrity);\n  \n  // Cover points\n  cover property (@(posedge clk) wr_en && !full);\n  cover property (@(posedge clk) rd_en && !empty);\n  cover property (@(posedge clk) full);\n  cover property (@(posedge clk) empty);\n  \nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0;\n  logic wr_en = 0, rd_en = 0;\n  logic [7:0] din = 0, dout;\n  logic full, empty;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"Testing FIFO with SystemVerilog assertions...\");\n    \n    // Reset\n    #10 rst_n = 1;\n    \n    // Write some data\n    for (int i = 1; i <= 5; i++) begin\n      @(posedge clk);\n      wr_en = 1;\n      din = i;\n      if (full) begin\n        $display(\"FIFO full at i=%0d\", i);\n        wr_en = 0;\n        break;\n      end\n    end\n    \n    // Read data\n    wr_en = 0;\n    for (int i = 0; i < 5; i++) begin\n      @(posedge clk);\n      rd_en = 1;\n      if (empty) begin\n        $display(\"FIFO empty\");\n        rd_en = 0;\n        break;\n      end\n    end\n    \n    // Test simultaneous read/write\n    @(posedge clk);\n    wr_en = 1; rd_en = 1;\n    din = 8'hAA;\n    #1;\n    \n    $display(\"\\nSimulation complete. Check assertion results.\");\n    #50 $finish;\n  end\n  \n  // Monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] wr_en=%0d, din=%0d, rd_en=%0d, dout=%0d, full=%0d, empty=%0d\",\n            $time, wr_en, din, rd_en, dout, full, empty);\n  end\nendmodule"
  },
  {
    "id": "arbiter_sv",
    "title": "Round Robin Arbiter with Assertions",
    "description": "Implement a 4-port round-robin arbiter with formal properties to ensure fairness.",
    "difficulty": "hard",
    "category": "Arbitration",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module #(\n  parameter PORTS = 4\n)(\n  input logic clk, rst_n,\n  input logic [PORTS-1:0] request,\n  output logic [PORTS-1:0] grant\n);\n  \n  logic [PORTS-1:0] last_grant;\n  logic [PORTS-1:0] masked_request;\n  logic [PORTS-1:0] unmasked_grant;\n  \n  // Your arbiter implementation here\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      last_grant <= 1;\n      grant <= 0;\n    end else begin\n      // Round robin logic\n      masked_request = request & ~((last_grant - 1) | last_grant);\n      if (|masked_request) begin\n        // Priority encoder for masked requests\n        unmasked_grant = 0;\n        for (int i = 0; i < PORTS; i++) begin\n          if (masked_request[i]) begin\n            unmasked_grant[i] = 1;\n            break;\n          end\n        end\n      end else begin\n        // Priority encoder for all requests\n        unmasked_grant = 0;\n        for (int i = 0; i < PORTS; i++) begin\n          if (request[i]) begin\n            unmasked_grant[i] = 1;\n            break;\n          end\n        end\n      end\n      \n      grant <= unmasked_grant;\n      if (|unmasked_grant) last_grant <= unmasked_grant;\n    end\n  end\n  \n  // Assertions\n  property p_one_hot_grant;\n    @(posedge clk) disable iff (!rst_n)\n    $onehot0(grant);\n  endproperty\n  a_one_hot_grant: assert property (p_one_hot_grant);\n  \n  property p_grant_only_when_requested;\n    @(posedge clk) disable iff (!rst_n)\n    grant |-> (request & grant) != 0;\n  endproperty\n  a_grant_only_when_requested: assert property (p_grant_only_when_requested);\n  \n  property p_fairness;\n    @(posedge clk) disable iff (!rst_n)\n    (request != 0) throughout (##[1:10] (grant == request & ~last_grant));\n  endproperty\n  a_fairness: assert property (p_fairness);\n  \n  // Cover points\n  genvar i;\n  generate\n    for (i = 0; i < PORTS; i++) begin\n      cover property (@(posedge clk) grant[i]);\n      cover property (@(posedge clk) request[i] && grant[i]);\n    end\n  endgenerate\n  \nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0;\n  logic [3:0] request = 0, grant;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"Testing Round Robin Arbiter with SystemVerilog assertions...\");\n    \n    // Reset\n    #10 rst_n = 1;\n    \n    // Test sequence\n    request = 4'b0001; #20;\n    request = 4'b0010; #20;\n    request = 4'b0100; #20;\n    request = 4'b1000; #20;\n    \n    // Test multiple requests\n    request = 4'b0110; #30;\n    \n    // Test no requests\n    request = 4'b0000; #20;\n    \n    $display(\"\\nSimulation complete. Check assertion results.\");\n    #50 $finish;\n  end\n  \n  // Monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] request=%4b, grant=%4b\", $time, request, grant);\n  end\nendmodule"
  },
  {
    "id": "assertions_basics",
    "title": "SystemVerilog Assertions Tutorial",
    "description": "Learn basic SystemVerilog assertions: immediate, concurrent, sequences, and properties.",
    "difficulty": "easy",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module(input logic clk, rst_n, a, b, c, output logic out);\n  \n  // Simple combinational logic\n  assign out = a & b;\n  \n  // 1. Immediate assertion\n  always_comb begin\n    assert_immediate: assert (out === (a & b))\n      else $error(\"Immediate assertion failed: a=%0d, b=%0d, out=%0d\", a, b, out);\n  end\n  \n  // 2. Concurrent assertion with sequence\n  sequence s_a_then_b;\n    a ##1 b;\n  endsequence\n  \n  property p_a_then_b;\n    @(posedge clk) disable iff (!rst_n)\n    s_a_then_b;\n  endproperty\n  a_a_then_b: assert property (p_a_then_b);\n  \n  // 3. Property with implication\n  property p_a_implies_b;\n    @(posedge clk) disable iff (!rst_n)\n    a |-> ##[1:3] b;\n  endproperty\n  a_a_implies_b: assert property (p_a_implies_b);\n  \n  // 4. Cover property\n  cover_a_and_b: cover property (@(posedge clk) a && b);\n  \n  // 5. Assume property\n  assume_no_glitch: assume property (@(posedge clk) $stable(a) || $stable(b));\n  \n  // Monitor\n  initial begin\n    $monitor(\"[%0t] a=%0d, b=%0d, out=%0d\", $time, a, b, out);\n  end\n  \nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0;\n  logic a = 0, b = 0, c = 0, out;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"SystemVerilog Assertions Tutorial\");\n    \n    // Reset\n    #10 rst_n = 1;\n    \n    // Test 1: Basic AND\n    a = 1; b = 1; #10;\n    \n    // Test 2: Sequence a then b\n    a = 1; #10;\n    b = 1; #10;\n    \n    // Test 3: Implication\n    a = 1; #10;\n    b = 1; #10;\n    \n    // Test with failure case\n    a = 1; b = 0; #10;\n    \n    $display(\"\\nTutorial complete. Check assertion results above.\");\n    #50 $finish;\n  end\n  \n  // Clock monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] posedge clk\", $time);\n  end\nendmodule"
  }
]
