[
  {
    "id": "and_gate_sv",
    "title": "AND Gate with Assertions",
    "description": "Implement a 2-input AND gate with SystemVerilog assertions to verify functionality.",
    "difficulty": "easy",
    "category": "Combinational Logic",
    "supports_sv": true,
    "has_assertions": true,
    "template": "`timescale 1ns/1ps\nmodule top_module(\n  input  logic a,\n  input  logic b,\n  output logic out\n);\n  // Implement AND gate\n  assign out = a & b;\n\n  // Assertion: output must always match AND logic\n  always_comb begin\n    assert (out === (a & b))\n      else $error(\"AND gate failed: a=%0d, b=%0d, out=%0d\", a, b, out);\n  end\n\n  initial begin\n    $display(\"Starting AND gate simulation with assertions...\");\n  end\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic a, b;\n  logic out;\n  integer passed = 0;\n  integer total = 0;\n\n  top_module dut (.*);\n\n  initial begin\n    $display(\"Testing AND gate with SystemVerilog...\");\n\n    // Test all combinations\n    for (int i = 0; i < 4; i++) begin\n      {a, b} = i;\n      #10;\n      total++;\n      if (out === (a & b)) begin\n        passed++;\n        $display(\"PASS: a=%0d, b=%0d, out=%0d\", a, b, out);\n      end else begin\n        $display(\"FAIL: a=%0d, b=%0d, out=%0d (expected %0d)\", a, b, out, a & b);\n      end\n    end\n\n    $display(\"\\nTest Results: %0d/%0d passed\", passed, total);\n    if (passed === total)\n      $display(\"PASS\");\n    else\n      $display(\"FAIL\");\n\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "or_gate_assert_only",
    "title": "OR Gate – Assertion Only",
    "description": "Implement a 2-input OR gate and verify correctness using only SystemVerilog assertions inside the design.",
    "difficulty": "easy",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "`timescale 1ns/1ps\nmodule top_module(\n  input  logic a,\n  input  logic b,\n  output logic out\n);\n  // OR gate logic\n  assign out = a | b;\n\n  // Assertion-only verification\n  always_comb begin\n    assert (out === (a | b))\n      else $fatal(1, \"Assertion failed: a=%0d b=%0d out=%0d\", a, b, out);\n  end\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic a, b;\n  logic out;\n\n  top_module dut (.*);\n\n  initial begin\n    for (int i = 0; i < 4; i++) begin\n      {a, b} = i;\n      #5;\n    end\n    $display(\"Simulation completed – assertions verified logic\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "unique_roll_numbers",
    "title": "Unique Student Roll Numbers",
    "description": "Generate 3 student roll numbers such that each roll number is between 1 and 100 and all three are different.",
    "difficulty": "easy",
    "category": "Constraints",
    "supports_sv": true,
    "has_assertions": false,
    "template": "class roll_numbers;\n  rand int r1, r2, r3;\n\n  constraint range_c {\n    r1 inside {[1:100]};\n    r2 inside {[1:100]};\n    r3 inside {[1:100]};\n  }\n\n  constraint unique_c {\n    r1 != r2;\n    r2 != r3;\n    r1 != r3;\n  }\nendclass",
    "testbench_sv": "module tb();\n  initial begin\n    roll_numbers rn = new();\n    if (rn.randomize())\n      $display(\"Rolls: %0d %0d %0d\", rn.r1, rn.r2, rn.r3);\n    else\n      $display(\"Randomization failed\");\n    $finish;\n  end\nendmodule"
  },

  {
    "id": "aligned_packet",
    "title": "Aligned Packet Generation",
    "description": "Generate a packet ensuring addr is word-aligned and id is within a valid range.",
    "difficulty": "easy",
    "category": "Constraints",
    "supports_sv": true,
    "has_assertions": false,
    "template": "class packet;\n  rand bit [31:0] addr;\n  rand bit [31:0] data;\n  rand bit [3:0]  id;\n\n  constraint addr_align_c { addr % 4 == 0; }\n  constraint id_range_c  { id inside {[1:10]}; }\nendclass",
    "testbench_sv": "module tb();\n  initial begin\n    packet p = new();\n    if (p.randomize())\n      $display(\"addr=%0h data=%0h id=%0d\", p.addr, p.data, p.id);\n    else\n      $display(\"Randomization failed\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "secure_pin",
    "title": "Secure 4-Digit PIN",
    "description": "Generate a 4-digit PIN with no repeated digits and the first digit not equal to zero.",
    "difficulty": "medium",
    "category": "Constraints",
    "supports_sv": true,
    "has_assertions": false,
    "template": "class pin_gen;\n  rand int pin[4];\n\n  constraint digit_range_c {\n    foreach (pin[i]) pin[i] inside {[0:9]};\n  }\n\n  constraint no_repeat_c {\n    unique {pin};\n  }\n\n  constraint no_leading_zero_c {\n    pin[0] != 0;\n  }\nendclass",
    "testbench_sv": "module tb();\n  initial begin\n    pin_gen p = new();\n    if (p.randomize())\n      $display(\"PIN: %0d%0d%0d%0d\", p.pin[0], p.pin[1], p.pin[2], p.pin[3]);\n    else\n      $display(\"Randomization failed\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "req_ack_assert",
    "title": "Request Acknowledge Assertion",
    "description": "Assert that ack is asserted within 3 cycles after req.",
    "difficulty": "medium",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "`timescale 1ns/1ps\nmodule top_module(input logic clk, req, ack);\n  property req_ack_p;\n    @(posedge clk) req |-> ##[1:3] ack;\n  endproperty\n\n  assert property (req_ack_p)\n    else $fatal(\"Ack not received within 3 cycles\");\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, req = 0, ack = 0;\n  always #5 clk = ~clk;\n\n  top_module dut (.*);\n\n  initial begin\n    #10 req = 1; #10 req = 0;\n    #20 ack = 1; #10 ack = 0;\n    #50 $finish;\n  end\nendmodule"
  },
  {
    "id": "fifo_underflow_assert",
    "title": "FIFO Underflow Protection",
    "description": "Ensure that a read never occurs when FIFO is empty.",
    "difficulty": "medium",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "`timescale 1ns/1ps\nmodule top_module(input logic clk, rd_en, empty);\n  property no_underflow_p;\n    @(posedge clk) !(rd_en && empty);\n  endproperty\n\n  assert property (no_underflow_p)\n    else $fatal(\"FIFO underflow detected\");\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rd_en = 0, empty = 1;\n  always #5 clk = ~clk;\n\n  top_module dut (.*);\n\n  initial begin\n    #10 rd_en = 1;\n    #20 empty = 0;\n    #20 rd_en = 0;\n    #50 $finish;\n  end\nendmodule"
  },
  {
    "id": "sequence_assertion",
    "title": "Sequence Detection with SVA",
    "description": "Implement a 101 sequence detector with SystemVerilog Assertions",
    "difficulty": "medium",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module sequence_detector(\n  input  logic clk,\n  input  logic reset,\n  input  logic data,\n  output logic detected\n);\n  // Your implementation here\n  logic [1:0] state;\n  \n  always_ff @(posedge clk) begin\n    if (reset) begin\n      state <= 2'b00;\n      detected <= 0;\n    end else begin\n      case(state)\n        2'b00: detected <= 0;\n        2'b01: detected <= 0;\n        2'b10: detected <= 1;\n        default: detected <= 0;\n      endcase\n      \n      // Simple 101 detection\n      case(state)\n        2'b00: state <= data ? 2'b01 : 2'b00;\n        2'b01: state <= data ? 2'b01 : 2'b10;\n        2'b10: state <= data ? 2'b01 : 2'b00;\n        default: state <= 2'b00;\n      endcase\n    end\n  end\n  \n  // SVA: Detect sequence 101\n  property p_sequence_101;\n    @(posedge clk) disable iff (reset)\n    data ##1 !data ##1 data |-> detected;\n  endproperty\n  \n  assert property(p_sequence_101)\n    else $error(\"Sequence 101 detection failed\");\n  \nendmodule",
    "testbench_sv": "module tb_sequence();\n  logic clk = 0;\n  logic reset;\n  logic data;\n  logic detected;\n  \n  always #5 clk = ~clk;\n  \n  sequence_detector dut (\n    .clk(clk),\n    .reset(reset),\n    .data(data),\n    .detected(detected)\n  );\n  \n  initial begin\n    reset = 1;\n    data = 0;\n    #20 reset = 0;\n    \n    // Test sequence: 1, 0, 1 (should detect)\n    data = 1; #10;\n    data = 0; #10;\n    data = 1; #10;\n    \n    // Wait for detection\n    #20;\n    \n    if (detected) begin\n      $display(\"PASS: Sequence 101 detected successfully\");\n    end else begin\n      $display(\"FAIL: Sequence not detected\");\n    end\n    \n    #50;\n    $display(\"Test complete\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "cover_property_example",
    "title": "Coverage Properties",
    "description": "Learn to use cover properties in SystemVerilog",
    "difficulty": "medium",
    "category": "Coverage",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module cover_example(\n  input  logic clk,\n  input  logic req,\n  input  logic ack,\n  output logic done\n);\n  logic [1:0] state;\n  \n  // Simple state machine\n  always_ff @(posedge clk) begin\n    if (req) state <= 2'b01;\n    else if (ack) state <= 2'b10;\n    else if (done) state <= 2'b00;\n  end\n  \n  assign done = (state == 2'b10);\n  \n  // Cover property: req followed by ack\n  cover property (@(posedge clk) req ##[1:5] ack)\n    $display(\"Cover hit: req->ack\");\n  \n  // Cover all states\n  cover property (@(posedge clk) state == 2'b00);\n  cover property (@(posedge clk) state == 2'b01);\n  cover property (@(posedge clk) state == 2'b10);\n  \nendmodule",
    "testbench_sv": "module tb();\n  logic clk = 0;\n  logic req, ack, done;\n  \n  always #5 clk = ~clk;\n  \n  cover_example dut (.*);\n  \n  initial begin\n    req = 0; ack = 0;\n    #20;\n    \n    // Generate some coverage\n    repeat (3) begin\n      req = 1; #10;\n      req = 0; #20;\n      ack = 1; #10;\n      ack = 0; #20;\n    end\n    \n    #100;\n    $display(\"Coverage test complete\");\n    $finish;\n  end\nendmodule"
  },
  {
    "id": "dff_sv",
    "title": "D Flip-Flop with Properties",
    "description": "Implement a positive-edge triggered D flip-flop with SystemVerilog properties and assertions.",
    "difficulty": "medium",
    "category": "Sequential Logic",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module(input logic clk, rst_n, d, output logic q);\n  // Implement D flip-flop\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) q <= 0;\n    else q <= d;\n  end\n  \n  // Assertions\n  property p_reset;\n    @(negedge rst_n) !rst_n |=> q == 0;\n  endproperty\n  a_reset: assert property (p_reset);\n  \n  property p_data_flow;\n    @(posedge clk) disable iff (!rst_n)\n    d |=> q == d;\n  endproperty\n  a_data_flow: assert property (p_data_flow);\n  \n  // Coverage\n  cover property (@(posedge clk) d == 1);\n  cover property (@(posedge clk) d == 0);\n  cover property (@(negedge rst_n) 1);\nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0, d = 0;\n  logic q;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"Testing D Flip-Flop with SystemVerilog assertions...\");\n    \n    // Reset sequence\n    #10 rst_n = 1;\n    \n    // Test data flow\n    d = 1; #10;\n    d = 0; #10;\n    d = 1; #10;\n    \n    // Test async reset\n    rst_n = 0; #5;\n    rst_n = 1; #5;\n    \n    $display(\"\\nSimulation complete. Check assertion results above.\");\n    #20 $finish;\n  end\n  \n  // Monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] clk posedge: d=%0d, q=%0d\", $time, d, q);\n  end\nendmodule"
  },
  {
    "id": "fifo_sv",
    "title": "FIFO with Assertions",
    "description": "Implement a synchronous FIFO with depth 4 and full SystemVerilog assertions for protocol checking.",
    "difficulty": "hard",
    "category": "Memory Elements",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module #(\n  parameter DEPTH = 4,\n  parameter WIDTH = 8\n)(\n  input logic clk, rst_n,\n  input logic wr_en, rd_en,\n  input logic [WIDTH-1:0] din,\n  output logic [WIDTH-1:0] dout,\n  output logic full, empty\n);\n  \n  logic [WIDTH-1:0] mem [0:DEPTH-1];\n  logic [$clog2(DEPTH):0] wr_ptr, rd_ptr;\n  \n  // Your FIFO implementation here\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      for (int i = 0; i < DEPTH; i++) mem[i] <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr[$clog2(DEPTH)-1:0]] <= din;\n        wr_ptr <= wr_ptr + 1;\n      end\n      \n      if (rd_en && !empty) begin\n        dout <= mem[rd_ptr[$clog2(DEPTH)-1:0]];\n        rd_ptr <= rd_ptr + 1;\n      end\n    end\n  end\n  \n  assign full = (wr_ptr - rd_ptr) == DEPTH;\n  assign empty = (wr_ptr == rd_ptr);\n  \n  // Assertions\n  property p_no_write_when_full;\n    @(posedge clk) disable iff (!rst_n)\n    full |-> !wr_en;\n  endproperty\n  a_no_write_when_full: assert property (p_no_write_when_full);\n  \n  property p_no_read_when_empty;\n    @(posedge clk) disable iff (!rst_n)\n    empty |-> !rd_en;\n  endproperty\n  a_no_read_when_empty: assert property (p_no_read_when_empty);\n  \n  property p_data_integrity;\n    @(posedge clk) disable iff (!rst_n)\n    (wr_en && !full) ##1 (rd_en && !empty) |-> dout == $past(din, 1);\n  endproperty\n  a_data_integrity: assert property (p_data_integrity);\n  \n  // Cover points (with proper clock)\n  cover property (@(posedge clk) wr_en && !full);\n  cover property (@(posedge clk) rd_en && !empty);\n  cover property (@(posedge clk) full);\n  cover property (@(posedge clk) empty);\n  \nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0;\n  logic wr_en = 0, rd_en = 0;\n  logic [7:0] din = 0, dout;\n  logic full, empty;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"Testing FIFO with SystemVerilog assertions...\");\n    \n    // Reset\n    #10 rst_n = 1;\n    \n    // Write some data\n    for (int i = 1; i <= 5; i++) begin\n      @(posedge clk);\n      wr_en = 1;\n      din = i;\n      if (full) begin\n        $display(\"FIFO full at i=%0d\", i);\n        wr_en = 0;\n        break;\n      end\n    end\n    \n    // Read data\n    wr_en = 0;\n    for (int i = 0; i < 5; i++) begin\n      @(posedge clk);\n      rd_en = 1;\n      if (empty) begin\n        $display(\"FIFO empty\");\n        rd_en = 0;\n        break;\n      end\n    end\n    \n    // Test simultaneous read/write\n    @(posedge clk);\n    wr_en = 1; rd_en = 1;\n    din = 8'hAA;\n    #1;\n    \n    $display(\"\\nSimulation complete. Check assertion results.\");\n    #50 $finish;\n  end\n  \n  // Monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] wr_en=%0d, din=%0d, rd_en=%0d, dout=%0d, full=%0d, empty=%0d\",\n            $time, wr_en, din, rd_en, dout, full, empty);\n  end\nendmodule"
  },
  {
    "id": "assertions_basics",
    "title": "SystemVerilog Assertions Tutorial",
    "description": "Learn basic SystemVerilog assertions: immediate, concurrent, sequences, and properties.",
    "difficulty": "easy",
    "category": "Assertions",
    "supports_sv": true,
    "has_assertions": true,
    "template": "module top_module(input logic clk, rst_n, a, b, c, output logic out);\n  \n  // Simple combinational logic\n  assign out = a & b;\n  \n  // 1. Immediate assertion\n  always_comb begin\n    assert_immediate: assert (out === (a & b))\n      else $error(\"Immediate assertion failed: a=%0d, b=%0d, out=%0d\", a, b, out);\n  end\n  \n  // 2. Concurrent assertion with sequence\n  sequence s_a_then_b;\n    a ##1 b;\n  endsequence\n  \n  property p_a_then_b;\n    @(posedge clk) disable iff (!rst_n)\n    s_a_then_b;\n  endproperty\n  a_a_then_b: assert property (p_a_then_b);\n  \n  // 3. Property with implication\n  property p_a_implies_b;\n    @(posedge clk) disable iff (!rst_n)\n    a |-> ##[1:3] b;\n  endproperty\n  a_a_implies_b: assert property (p_a_implies_b);\n  \n  // 4. Cover property (must have clock)\n  cover_a_and_b: cover property (@(posedge clk) a && b);\n  \n  // 5. Assume property\n  assume_no_glitch: assume property (@(posedge clk) $stable(a) || $stable(b));\n  \n  // Monitor\n  initial begin\n    $monitor(\"[%0t] a=%0d, b=%0d, out=%0d\", $time, a, b, out);\n  end\n  \nendmodule",
    "testbench_sv": "`timescale 1ns/1ps\nmodule tb();\n  logic clk = 0, rst_n = 0;\n  logic a = 0, b = 0, c = 0, out;\n  \n  top_module dut (.*);\n  \n  always #5 clk = ~clk;\n  \n  initial begin\n    $display(\"SystemVerilog Assertions Tutorial\");\n    \n    // Reset\n    #10 rst_n = 1;\n    \n    // Test 1: Basic AND\n    a = 1; b = 1; #10;\n    \n    // Test 2: Sequence a then b\n    a = 1; #10;\n    b = 1; #10;\n    \n    // Test 3: Implication\n    a = 1; #10;\n    b = 1; #10;\n    \n    // Test with failure case\n    a = 1; b = 0; #10;\n    \n    $display(\"\\nTutorial complete. Check assertion results above.\");\n    #50 $finish;\n  end\n  \n  // Clock monitor\n  always @(posedge clk) begin\n    $display(\"[%0t] posedge clk\", $time);\n  end\nendmodule"
  }
]
